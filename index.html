<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Style Visualizer (client-side) - Fixed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    body { font-family: Arial, sans-serif; display:flex; gap:16px; padding:12px; flex-wrap:wrap; justify-content:center; }
    #controls { width:320px; max-width:90vw; }
    canvas { border:1px solid #ddd; max-width:360px; width:360px; height:auto; background:#fff; }
    .small { font-size:0.9rem; color:#444; margin-top:8px; }
    button, select, input { margin-top:8px; padding:8px 10px; width:100%; box-sizing:border-box; }
    .row { display:flex; gap:8px; }
    .hint { font-size:0.85rem; color:#666; margin-top:6px; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Try Your Look</h2>
    <input id="file" type="file" accept="image/*"><br>
    <label class="small">Or use a front-facing selfie (good light)</label><br>
    <select id="recipe">
      <option value="0">Recipe 1 — Classic (clean)</option>
      <option value="1">Recipe 2 — Textured + stubble</option>
      <option value="2">Recipe 3 — Formal + neat</option>
    </select>
    <button id="applyBtn">Generate Variant</button>
    <div class="hint">Tip: If alignment looks off, try a clearer front photo or use a slightly higher resolution.</div>
    <button id="downloadBtn">Download Current Image</button>
    <div class="small" id="privacy">Processed in your browser only — nothing is uploaded.</div>
    <div class="small" id="logarea"></div>
  </div>

  <div>
    <canvas id="output" width="720" height="960"></canvas>
    <div class="small">Use the download button to save the result. To save to your app, upload the image to Glide profile.</div>
  </div>

  <!-- MediaPipe face mesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // ===========================
  // FINAL LINKS: Corrected and integrated.
  // Replace these with your actual raw URLs if needed.
  // ===========================
  const overlays = {
    // Hairstyles
    hair_short: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle1.png',
    hair_long:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle6.png',
    hair_curly: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle2.png',
    hair_buzz:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle4.png',
    hair_ponytail:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle5.png',
    hair_fade:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle3.png',
    // Beards 
    beard_trim:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard1.png',
    beard_full:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard2.png',
    beard_goatee:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard3.png',
    beard_clean: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard4.png',
    // Outfits
    outfit_blazer:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit1.png',
    outfit_tshirt:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit2.png',
    outfit_hoodie:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit3.png',
    outfit_formal:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit4.png',
    outfit_party: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit5.png',
    outfit_ethnic:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit6.png'
  };
  // ===========================

  // Preload overlay images
  const overlayImgs = {};
  const overlayPromises = [];
  for (let k in overlays) {
    const im = new Image();
    im.crossOrigin = "anonymous";
    im.src = overlays[k];
    overlayImgs[k] = im;
    // push promise to wait if needed
    overlayPromises.push(new Promise((res)=> {
      if (im.complete) return res();
      im.onload = ()=> res();
      im.onerror = ()=> {
        console.warn('Overlay failed to load:', overlays[k]);
        res();
      };
    }));
  }

  const canvas = document.getElementById('output');
  const ctx = canvas.getContext('2d');
  let img = new Image();
  let currentLandmarks = null;
  let lastDrawState = null;
  let lastDrawParams = null;

  // small log helper
  function log(msg){
    console.log(msg);
    const area = document.getElementById('logarea');
    if (area) area.textContent = String(msg);
  }

  // ------------------------------
  // Handle file upload
  // ------------------------------
  document.getElementById('file').addEventListener('change', (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    img.onload = () => { 
      log('User image loaded; width=' + img.width + ' height=' + img.height);
      drawBase(); 
      processFaceMesh();
    };
    img.onerror = ()=> log('Failed to load user image');
    img.src = url;
  });

  // ------------------------------
  // Draw base image (fit into canvas)
  // ------------------------------
  function drawBase(){
    if (!img || !img.src) return;
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    const scale = Math.min(w/img.width, h/img.height);
    const drawW = img.width*scale, drawH = img.height*scale;
    const dx = (w-drawW)/2, dy=(h-drawH)/2;
    lastDrawParams = {dx, dy, scale, drawW, drawH};
    ctx.drawImage(img, dx, dy, drawW, drawH);
  }

  // ------------------------------
  // MediaPipe setup
  // ------------------------------
  const faceMesh = new FaceMesh({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
  }});
  faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5});
  faceMesh.onResults(onFaceResults);

  async function processFaceMesh(){
    if (!img || !img.src) return;
    try {
      const imageBitmap = await createImageBitmap(img);
      await faceMesh.send({image: imageBitmap});
    } catch (err){
      console.error('processFaceMesh error', err);
      alert('Face processing failed. Try a different photo.');
    }
  }

  function onFaceResults(results){
    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0) {
      alert('Face not detected. Try a clearer front-facing photo.');
      return;
    }
    currentLandmarks = results.multiFaceLandmarks[0];
    log('Face landmarks detected: ' + currentLandmarks.length);
    drawComposites();
  }

  // Map MediaPipe normalized coordinates to our canvas coordinates using lastDrawParams
  function toCanvasPoint(normPt){
    const p = lastDrawParams;
    if (!p) return {x:0,y:0};
    const x = p.dx + normPt.x * p.drawW;
    const y = p.dy + normPt.y * p.drawH;
    return {x, y};
  }

  // ==========================================================
  // drawOverlay now takes angle and headWidth as parameters (fixed)
  // ==========================================================
  function drawOverlay(imgObj, centerX, centerY, scaleFactor, vertOffsetFactor, angle, headWidth){
    if (!imgObj) return;
    if (!imgObj.complete) {
      // if image hasn't loaded yet, set onload to redraw once ready
      imgObj.onload = () => {
        try { drawComposites(); } catch(e){ console.warn('redraw failed after overlay load', e); }
      };
      return;
    }
    // safe natural dimensions
    const iw = imgObj.naturalWidth || imgObj.width || 1;
    const ih = imgObj.naturalHeight || imgObj.height || 1;
    const imgW = Math.max(1, headWidth * scaleFactor);
    const imgH = imgW * (ih / iw);
    ctx.save();
    ctx.translate(centerX, centerY + (vertOffsetFactor || 0));
    ctx.rotate(angle);
    ctx.drawImage(imgObj, -imgW/2, -imgH/2, imgW, imgH);
    ctx.restore();
  }
  // ==========================================================

  function drawComposites(){
    // must have base drawn and landmarks
    drawBase();
    if (!currentLandmarks || !lastDrawParams) {
      log('No landmarks or draw params yet');
      return;
    }
    const lm = currentLandmarks;
    // key landmarks used
    const leftEye = toCanvasPoint(lm[33]), rightEye = toCanvasPoint(lm[263]), chin = toCanvasPoint(lm[152]);
    const leftShoulder = toCanvasPoint(lm[11] || lm[234] || lm[127]), rightShoulder = toCanvasPoint(lm[12] || lm[454] || lm[356]);

    // Head center and width (used to scale overlays)
    const eyeCenter = {x:(leftEye.x+rightEye.x)/2, y:(leftEye.y+rightEye.y)/2};
    const headWidth = Math.hypot(rightEye.x-leftEye.x, rightEye.y-leftEye.y);
    const angle = Math.atan2(rightEye.y-leftEye.y, rightEye.x-leftEye.x);

    // get recipe index safely
    const recipeIndex = Math.max(0, Math.min(2, parseInt(document.getElementById('recipe').value || '0')));
    const recipes = [
      { hair: 'hair_short', beard: 'beard_clean', outfit: 'outfit_formal' },
      { hair: 'hair_curly', beard: 'beard_trim', outfit: 'outfit_tshirt' },
      { hair: 'hair_fade', beard: 'beard_trim', outfit: 'outfit_blazer' }
    ];
    const chosen = recipes[recipeIndex] || recipes[0];
    log('Applying recipe ' + recipeIndex + ' -> ' + JSON.stringify(chosen));

    // Draw hair
    drawOverlay(overlayImgs[chosen.hair], eyeCenter.x, eyeCenter.y - headWidth*0.9, 2.4, -headWidth*0.8, angle, headWidth);

    // Draw beard
    drawOverlay(overlayImgs[chosen.beard], chin.x, chin.y + headWidth*0.06, 1.3, headWidth*0.04, angle, headWidth);

    // Draw outfit anchored at neck using shoulder width
    const shoulderWidth = Math.hypot(rightShoulder.x-leftShoulder.x, rightShoulder.y-leftShoulder.y) || (headWidth*2);
    const neckX = (leftShoulder.x+rightShoulder.x)/2;
    const neckY = (leftShoulder.y+rightShoulder.y)/2 - headWidth*0.6;
    drawOverlay(overlayImgs[chosen.outfit], neckX, neckY, (shoulderWidth * 1.2 / Math.max(headWidth,1)), 0, angle, headWidth);

    // Save current draw state for download
    try {
      lastDrawState = canvas.toDataURL('image/png');
    } catch (e) {
      console.warn('Could not create dataURL (CORS or tainting):', e);
      lastDrawState = null;
    }
  }

  // Generate (apply button)
  document.getElementById('applyBtn').addEventListener('click', async ()=>{
    if (!img.src) { alert('Upload a selfie first.'); return; }
    // ensure overlays loaded (wait briefly)
    await Promise.all(overlayPromises);
    processFaceMesh(); // faceMesh will call drawComposites when results ready
  });

  // Download current image
  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    if (!lastDrawState) {
      alert('No image generated yet. Upload a photo and click Generate.');
      return;
    }
    const link = document.createElement('a');
    link.download = 'styled_' + Date.now() + '.png';
    link.href = lastDrawState;
    link.click();
  });

  </script>
</body>
</html>
