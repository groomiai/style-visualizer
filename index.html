<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Style Visualizer (client-side)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    body { font-family: Arial, sans-serif; display:flex; gap:16px; padding:12px; flex-wrap:wrap; justify-content:center; }
    #controls { width:320px; max-width:90vw; }
    canvas { border:1px solid #ddd; max-width:360px; width:360px; height:auto; background:#fff; }
    .small { font-size:0.9rem; color:#444; margin-top:8px; }
    button, select, input { margin-top:8px; padding:8px 10px; width:100%; box-sizing:border-box; }
    .row { display:flex; gap:8px; }
    .hint { font-size:0.85rem; color:#666; margin-top:6px; }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Try Your Look</h2>
    <input id="file" type="file" accept="image/*"><br>
    <label class="small">Or use a front-facing selfie (good light)</label><br>
    <select id="recipe">
      <option value="0">Recipe 1 — Classic (clean)</option>
      <option value="1">Recipe 2 — Textured + stubble</option>
      <option value="2">Recipe 3 — Formal + neat</option>
    </select>
    <button id="applyBtn">Generate Variant</button>
    <div class="hint">Tip: If alignment looks off, try a clearer front photo or use a slightly higher resolution.</div>
    <button id="downloadBtn">Download Current Image</button>
    <div class="small" id="privacy">Processed in your browser only — nothing is uploaded.</div>
  </div>

  <div>
    <canvas id="output" width="720" height="960"></canvas>
    <div class="small">Use the download button to save the result. To save to your app, upload the image to Glide profile.</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // ===========================
  // Replace these 4 URLs with your actual overlay image URLs (from imgbb or GitHub raw)
  // ===========================
  const overlays = {
  // Hairstyles
  // FIX 1: Added missing closing single quote '
  hair_short: 'https://ibb.co/kL1pbC1.png',
  hair_long: 'https://ibb.co/HLQd3Whr.png',
  hair_curly: 'https://ibb.co/7tC7yDYJ.png',
  hair_buzz: 'https://ibb.co/V0vknwhD.png',
  hair_ponytail: 'https://ibb.co/hRrv87mn.png',
  hair_fade: 'https://ibb.co/TDgD6yc7.png',
  // Beards
  beard_trim: 'https://ibb.co/LzzGv0x2.png',
  beard_full: 'https://ibb.co/MkJZfnGG.png',
  beard_goatee: 'https://ibb.co/pBxFFNT1.png',
  // FIX 1: Added missing closing single quote '
  beard_clean: 'https://ibb.co/Kxd6CwKJ',
  // Outfits
  outfit_blazer: 'https://ibb.co/NdsPwqGj.png',
  outfit_tshirt: 'https://ibb.co/G3RY3jdD.png',
  outfit_hoodie: 'https://ibb.co/WWc9xJN5.png',
  outfit_formal: 'https://ibb.co/C59GKdbT.png',
  outfit_party: 'https://ibb.co/FqzcpHGb.png',
  outfit_ethnic: 'https://ibb.co/7JdVZFdq.png'
  };
  // ===========================

  // Preload overlay images
  const overlayImgs = {};
  for (let k in overlays) {
    const im = new Image();
    im.crossOrigin = "anonymous"; // allow cross-origin if hosted externally
    im.src = overlays[k];
    overlayImgs[k] = im;
  }

  const canvas = document.getElementById('output');
  const ctx = canvas.getContext('2d');
  let img = new Image();
  let currentLandmarks = null;
  let lastDrawState = null;

  // ------------------------------
  // Handle file upload
  // ------------------------------
  document.getElementById('file').addEventListener('change', (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    img.onload = () => { drawBase(); processFaceMesh(); }
    img.src = url;
  });

  // ------------------------------
  // Draw base image (fit into canvas)
  // ------------------------------
  let lastDrawParams = null;
  function drawBase(){
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    // Fit image into canvas centered
    const scale = Math.min(w/img.width, h/img.height);
    const drawW = img.width*scale, drawH = img.height*scale;
    const dx = (w-drawW)/2, dy=(h-drawH)/2;
    // Save these values for mapping landmarks later
    lastDrawParams = {dx, dy, scale, drawW, drawH};
    ctx.drawImage(img, dx, dy, drawW, drawH);
  }

  // ------------------------------
  // MediaPipe setup
  // ------------------------------
  const faceMesh = new FaceMesh({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
  }});
  faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5});
  faceMesh.onResults(onFaceResults);

  async function processFaceMesh(){
    if (!img.src) return;
    // createImageBitmap for accurate input
    const imageBitmap = await createImageBitmap(img);
    await faceMesh.send({image: imageBitmap});
  }

  function onFaceResults(results){
    if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0) {
      alert('Face not detected. Try a clearer front-facing photo.');
      return;
    }
    currentLandmarks = results.multiFaceLandmarks[0];
    drawComposites();
  }

  // Map MediaPipe normalized coordinates to our canvas coordinates using lastDrawParams
  function toCanvasPoint(normPt){
    const p = lastDrawParams;
    // MediaPipe normalized coords are relative to the original input image.
    // We used createImageBitmap(img) so normalized coordinates match image width/height.
    const x = p.dx + normPt.x * p.drawW;
    const y = p.dy + normPt.y * p.drawH;
    return {x, y};
  }

  function drawComposites(){
    drawBase();
    if (!currentLandmarks) return;
    const lm = currentLandmarks;
    // landmarks: left eye ~33, right eye ~263, chin ~152, left shoulder ~11, right shoulder ~12 (approx)
    const leftEye = toCanvasPoint(lm[33]), rightEye = toCanvasPoint(lm[263]), chin = toCanvasPoint(lm[152]);
    const leftShoulder = toCanvasPoint(lm[11] || lm[234] || lm[127]), rightShoulder = toCanvasPoint(lm[12] || lm[454] || lm[356]);

    // Head center and width
    const eyeCenter = {x:(leftEye.x+rightEye.x)/2, y:(leftEye.y+rightEye.y)/2};
    const headWidth = Math.hypot(rightEye.x-leftEye.x, rightEye.y-leftEye.y);

    // Angle
    const angle = Math.atan2(rightEye.y-leftEye.y, rightEye.x-leftEye.x);

    // Helper to draw an overlay with rotation and scale
    function drawOverlay(imgObj, centerX, centerY, scaleFactor, vertOffsetFactor){
      const imgW = (headWidth * scaleFactor);
      const imgH = imgW * (imgObj.height / imgObj.width || 1.0);
      ctx.save();
      ctx.translate(centerX, centerY + (vertOffsetFactor || 0));
      ctx.rotate(angle);
      ctx.drawImage(imgObj, -imgW/2, -imgH/2, imgW, imgH);
      ctx.restore();
    }

    // Recipe selection: pick overlays for the selected recipe index
    const recipeIndex = parseInt(document.getElementById('recipe').value || '0');

    // Simple recipe mapping: you can expand these later
    // FIX 2: Corrected the definition of 'recipes' to be an array of objects
    // that use the keys from the 'overlays' variable.
    const recipes = [
      // Index 0: Recipe 1 — Classic (clean)
      { hair: 'hair_short', beard: 'beard_clean', outfit: 'outfit_formal' },
      // Index 1: Recipe 2 — Textured + stubble
      { hair: 'hair_curly', beard: 'beard_trim', outfit: 'outfit_tshirt' },
      // Index 2: Recipe 3 — Formal + neat
      { hair: 'hair_fade', beard: 'beard_trim', outfit: 'outfit_blazer' }
    ];
    const chosen = recipes[recipeIndex];

    // Draw hair (offset upward a bit)
    drawOverlay(overlayImgs[chosen.hair], eyeCenter.x, eyeCenter.y - headWidth*0.9, 2.4, -headWidth*0.8);

    // Draw beard at chin
    drawOverlay(overlayImgs[chosen.beard], chin.x, chin.y + headWidth*0.06, 1.3, headWidth*0.04);

    // Draw outfit anchored at neck (use shoulder width)
    const shoulderWidth = Math.hypot(rightShoulder.x-leftShoulder.x, rightShoulder.y-leftShoulder.y) || (headWidth*2);
    const neckX = (leftShoulder.x+rightShoulder.x)/2;
    const neckY = (leftShoulder.y+rightShoulder.y)/2 - headWidth*0.6;
    drawOverlay(overlayImgs[chosen.outfit], neckX, neckY, shoulderWidth * 1.2 / headWidth, 0);

    // Save current draw state for download
    lastDrawState = canvas.toDataURL('image/png');
  }

  // Generate (apply button)
  document.getElementById('applyBtn').addEventListener('click', ()=>{
    if (!img.src) { alert('Upload a selfie first.'); return; }
    // cycle recipes for demo: draw composite
    processFaceMesh(); // will call draw when results come
  });

  // Download current image
  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    if (!lastDrawState) {
      alert('No image generated yet. Upload a photo and click Generate.');
      return;
    }
    const link = document.createElement('a');
    link.download = 'styled_' + Date.now() + '.png';
    link.href = lastDrawState;
    link.click();
  });

  </script>
</body>
</html>
