<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Style Visualizer — Mirror Preview</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Inter, Arial, sans-serif; background:#f4f6f8; color:#111; margin:0; padding:18px; display:flex; gap:18px; flex-wrap:wrap; justify-content:center; }
    .panel { background:white; border-radius:10px; padding:14px; box-shadow:0 6px 18px rgba(30,40,60,0.06); }
    #left { width:360px; min-height:480px; }
    #right { width:740px; min-height:480px; }
    h2 { margin:0 0 10px 0; font-size:18px; }
    canvas { width:720px; height:960px; border-radius:6px; background:#fff; display:block; }
    input[type=file] { width:100%; }
    .recipes { display:flex; gap:8px; margin:10px 0 12px 0; flex-wrap:wrap; }
    .recipe-card { background:#fff; border:1px solid #eee; padding:8px 10px; border-radius:8px; cursor:pointer; min-width:160px; }
    .recipe-card.selected { border-color:#2563eb; box-shadow:0 6px 18px rgba(37,99,235,0.08); }
    label.small { display:block; font-size:12px; color:#555; margin-top:8px; }
    button { background:#2563eb; color:white; border:none; padding:10px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
    button.ghost { background:#fff; color:#111; border:1px solid #ddd; }
    .controls { margin-top:12px; display:flex; gap:8px; flex-direction:column; }
    .slider-row { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .slider-row input[type=range] { flex:1; }
    .log { margin-top:10px; font-size:12px; color:#666; min-height:16px; }
    .hint { font-size:13px; color:#444; margin-top:8px; }
    .top-row { display:flex; gap:12px; align-items:center; margin-bottom:8px; }
    a.link { color:#2563eb; text-decoration:none; font-size:13px; }
  </style>
</head>
<body>

  <div id="left" class="panel">
    <h2>Upload & Details</h2>
    <input id="file" type="file" accept="image/*">
    <div class="hint">Use a front-facing selfie with good light. No upload to server — processed in your browser.</div>

    <label class="small">Quick user info (optional)</label>
    <input id="occasion" placeholder="Occasion (wedding, interview, party)" />

    <div class="hint">Choose one of the 3 AI recipes below or let the app auto-select.</div>

    <div id="recipes" class="recipes"></div>

    <div class="controls">
      <button id="applyBtn">Apply Recipe</button>
      <div style="display:flex; gap:8px;">
        <button id="downloadBtn" class="ghost">Download</button>
        <button id="resetBtn" class="ghost">Reset</button>
      </div>

      <label class="small">Nudge & scale (use if overlay position needs small fix)</label>
      <div class="slider-row"><div style="width:70px">X offset</div><input id="nudgeX" type="range" min="-80" max="80" value="0"></div>
      <div class="slider-row"><div style="width:70px">Y offset</div><input id="nudgeY" type="range" min="-80" max="80" value="0"></div>
      <div class="slider-row"><div style="width:70px">Scale</div><input id="scale" type="range" min="50" max="200" value="100"></div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <div id="right" class="panel">
    <h2>Preview</h2>
    <canvas id="canvas" width="720" height="960"></canvas>
    <div class="hint">If overlays look off, use nudges. For production, AI should choose overlays by keys (see instructions).</div>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
  // ============================
  // OVERLAYS: your 16 raw images (from your earlier message)
  // Replace any URL here if you host different files.
  // ============================
  const overlays = {
  // Hairstyles (6)
  hair_short: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle1.png',
  hair_curly: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle2.png',
  hair_fade:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle3.png',
  hair_buzz:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle4.png',
  hair_ponytail:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle5.png',
  hair_long:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.hairstyle6.png',

  // Beards (4)
  beard_trim:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard1.png',
  beard_full:  'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard2.png',
  beard_goatee:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard3.png',
  beard_clean: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.beard4.png',

  // Outfits (6)
  outfit_blazer:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit1.png',
  outfit_tshirt:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit2.png',
  outfit_hoodie:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit3.png',
  outfit_formal:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit4.png',
  outfit_party: 'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit5.png',
  outfit_ethnic:'https://raw.githubusercontent.com/groomiai/style-visualizer/df581236ba40f6998beefa7c247ff3b91fda9276/groomi.outfit6.png'
  };

  // ============================
  // PRELOAD overlay images
  // ============================
  const overlayImgs = {};
  const overlayPromises = Object.keys(overlays).map(k => {
    return new Promise(res => {
      const im = new Image();
      im.crossOrigin = "anonymous";
      im.src = overlays[k];
      im.onload = () => { overlayImgs[k] = im; res(); };
      im.onerror = () => { console.warn('Overlay failed to load:', overlays[k]); overlayImgs[k] = im; res(); };
    });
  });

  // ============================
  // Recipe parsing from URL or fallback
  // Accept formats:
  // ?recipe1=hair_short,beard_trim,outfit_blazer&recipe2=...
  // or ?recipe1_hair=hair_short&recipe1_beard=beard_trim&recipe1_outfit=outfit_blazer
  // ============================
  function parseRecipesFromURL() {
    const params = new URLSearchParams(window.location.search);
    const recipes = [];
    for (let i = 1; i <= 3; i++) {
      const r = params.get(`recipe${i}`);
      if (r) {
        const parts = r.split(/[,\|]/).map(s => s.trim()).filter(Boolean);
        recipes.push({
          hair: parts[0] || null,
          beard: parts[1] || null,
          outfit: parts[2] || null,
          title: params.get(`recipe${i}_title`) || `Recipe ${i}`
        });
        continue;
      }
      // alternate format
      const hair = params.get(`recipe${i}_hair`);
      if (hair) {
        recipes.push({
          hair: hair,
          beard: params.get(`recipe${i}_beard`) || null,
          outfit: params.get(`recipe${i}_outfit`) || null,
          title: params.get(`recipe${i}_title`) || `Recipe ${i}`
        });
      }
    }
    // if zero found -> create 3 sensible defaults from overlays keys
    if (recipes.length === 0) {
      const hairKeys = Object.keys(overlays).filter(k=>k.startsWith('hair'));
      const beardKeys = Object.keys(overlays).filter(k=>k.startsWith('beard'));
      const outfitKeys = Object.keys(overlays).filter(k=>k.startsWith('outfit'));
      // create 3 combos (rotate)
      for (let i=0;i<3;i++) {
        recipes.push({
          hair: hairKeys[i % hairKeys.length] || null,
          beard: beardKeys[i % beardKeys.length] || null,
          outfit: outfitKeys[i % outfitKeys.length] || null,
          title: ['Classic','Trendy','Formal'][i] || `Recipe ${i+1}`
        });
      }
    }
    return recipes;
  }

  // Build UI recipe cards
  const recipesUI = document.getElementById('recipes');
  let recipes = parseRecipesFromURL();
  let selectedRecipeIndex = 0;

  function renderRecipes() {
    recipesUI.innerHTML = '';
    recipes.forEach((r, idx) => {
      const div = document.createElement('div');
      div.className = 'recipe-card' + (idx===selectedRecipeIndex ? ' selected':'' );
      div.innerHTML = `<strong>${r.title || 'Recipe ' + (idx+1)}</strong><div style="font-size:13px;color:#666;margin-top:6px;">
        ${r.hair || ''} / ${r.beard || ''} / ${r.outfit || ''}</div>`;
      div.onclick = () => { selectedRecipeIndex = idx; updateSelectedUI(); previewRecipe(idx); };
      recipesUI.appendChild(div);
    });
  }

  function updateSelectedUI(){ Array.from(recipesUI.children).forEach((c,i)=>c.classList.toggle('selected', i===selectedRecipeIndex)); }
  renderRecipes();

  // ============================
  // Canvas + MediaPipe setup
  // ============================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const fileInput = document.getElementById('file');
  const nudgeX = document.getElementById('nudgeX');
  const nudgeY = document.getElementById('nudgeY');
  const scaleRange = document.getElementById('scale');

  const logEl = document.getElementById('log');
  function log(s){ console.log(s); logEl.textContent = typeof s==='string' ? s : JSON.stringify(s); }

  let userImage = new Image();
  let lastDrawParams = null;
  let lastLandmarks = null;
  let lastDataURL = null;

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    userImage.onload = () => { drawBase(); log('Image loaded'); };
    userImage.onerror = ()=> log('Failed to load image');
    userImage.src = url;
    // clear previous landmarks
    lastLandmarks = null;
  });

  function drawBase() {
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    if (!userImage || !userImage.src) return;
    const scale = Math.min(w / userImage.width, h / userImage.height);
    const drawW = userImage.width * scale, drawH = userImage.height * scale;
    const dx = (w - drawW) / 2, dy = (h - drawH) / 2;
    lastDrawParams = {dx, dy, drawW, drawH, scale};
    ctx.drawImage(userImage, dx, dy, drawW, drawH);
  }

  // FaceMesh instance
  const faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
  faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5});
  faceMesh.onResults(onFaceResults);

  async function runFaceMeshOnImage() {
    if (!userImage || !userImage.src) { alert('Upload a selfie first'); return; }
    // ensure overlays loaded
    await Promise.all(overlayPromises);
    try {
      const bitmap = await createImageBitmap(userImage);
      await faceMesh.send({image: bitmap});
    } catch (err) {
      console.error('face mesh send error', err);
      alert('Face processing failed. Try another photo or reload the page.');
    }
  }

  function toCanvasPoint(normPt) {
    if (!lastDrawParams) return {x:0,y:0};
    return {
      x: lastDrawParams.dx + normPt.x * lastDrawParams.drawW,
      y: lastDrawParams.dy + normPt.y * lastDrawParams.drawH
    };
  }

  // drawOverlay receives headWidth and angle explicitly
  function drawOverlay(imgObj, centerX, centerY, scaleFactor, vertOffset, angle, headWidth) {
    if (!imgObj) return;
    if (!imgObj.complete) {
      // wait for load then redraw
      imgObj.onload = () => { try { drawComposites(lastLandmarks); } catch(e) {} };
      return;
    }
    const iw = imgObj.naturalWidth || imgObj.width || 1;
    const ih = imgObj.naturalHeight || imgObj.height || 1;
    const finalW = Math.max(1, headWidth * scaleFactor * (scaleRange.value/100));
    const finalH = finalW * (ih / iw);
    ctx.save();
    ctx.translate(centerX + parseInt(nudgeX.value || 0), centerY + (vertOffset || 0) + parseInt(nudgeY.value || 0));
    ctx.rotate(angle);
    ctx.drawImage(imgObj, -finalW/2, -finalH/2, finalW, finalH);
    ctx.restore();
  }

  // drawComposites computes geometry and draws the three layers
  function drawComposites(landmarks) {
    // Draw base image
    drawBase();
    if (!landmarks) { log('No landmarks to draw overlays'); return; }
    lastLandmarks = landmarks;

    // pick landmark points
    const leftEye = toCanvasPoint(landmarks[33]);
    const rightEye = toCanvasPoint(landmarks[263]);
    const chin = toCanvasPoint(landmarks[152]);
    // shoulders fallback (face mesh sometimes includes shoulders via extended landmarks; use estimates)
    const leftShoulder = toCanvasPoint(landmarks[11] || landmarks[234] || landmarks[127]);
    const rightShoulder = toCanvasPoint(landmarks[12] || landmarks[454] || landmarks[356]);

    // compute metrics
    const eyeCenter = { x: (leftEye.x + rightEye.x) / 2, y: (leftEye.y + rightEye.y) / 2 };
    const headWidth = Math.hypot(rightEye.x - leftEye.x, rightEye.y - leftEye.y);
    const angle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);

    // which recipe chosen
    const recipe = recipes[selectedRecipeIndex] || recipes[0];

    // draw outfit first (behind), anchored at neck area
    const shoulderWidth = Math.hypot(rightShoulder.x - leftShoulder.x, rightShoulder.y - leftShoulder.y) || (headWidth * 2);
    const neckX = (leftShoulder.x + rightShoulder.x) / 2 || eyeCenter.x;
    const neckY = (leftShoulder.y + rightShoulder.y) / 2 - headWidth * 0.6 || chin.y - headWidth*0.8;

    if (recipe.outfit && overlayImgs[recipe.outfit]) {
      drawOverlay(overlayImgs[recipe.outfit], neckX, neckY, (shoulderWidth*1.2 / Math.max(headWidth,1)), 0, angle, Math.max(headWidth,1));
    }

    // draw hair (top)
    if (recipe.hair && overlayImgs[recipe.hair]) {
      drawOverlay(overlayImgs[recipe.hair], eyeCenter.x, eyeCenter.y - headWidth * 0.9, 2.4, -headWidth*0.8, angle, Math.max(headWidth,1));
    }

    // draw beard
    if (recipe.beard && overlayImgs[recipe.beard]) {
      drawOverlay(overlayImgs[recipe.beard], chin.x, chin.y + headWidth * 0.06, 1.3, headWidth * 0.04, angle, Math.max(headWidth,1));
    }

    // save for download (try/catch for CORS)
    try {
      lastDataURL = canvas.toDataURL('image/png');
    } catch (e) {
      console.warn('Could not generate dataURL:', e);
      lastDataURL = null;
    }
    log('Rendered recipe: ' + (recipe.title||'') + ' — headWidth:' + Math.round(headWidth));
  }

  // FaceMesh results callback
  function onFaceResults(results) {
    if (!results || !results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
      log('Face not detected — try a clearer photo');
      return;
    }
    const landmarks = results.multiFaceLandmarks[0];
    drawComposites(landmarks);
  }

  // UI handlers
  document.getElementById('applyBtn').addEventListener('click', async () => {
    if (!userImage || !userImage.src) { alert('Upload a selfie first'); return; }
    await runFaceMeshOnImage();
  });
  document.getElementById('downloadBtn').addEventListener('click', () => {
    if (!lastDataURL) { alert('No generated image yet — Apply a recipe first'); return; }
    const a = document.createElement('a');
    a.href = lastDataURL;
    a.download = 'styled_' + Date.now() + '.png';
    a.click();
  });
  document.getElementById('resetBtn').addEventListener('click', () => {
    userImage = new Image();
    fileInput.value = '';
    ctx.clearRect(0,0,canvas.width,canvas.height);
    lastDataURL = null;
    lastLandmarks = null;
    log('Reset');
  });

  // recipe preview: draw the recipe without face detection (use estimated positions)
  function previewRecipe(idx) {
    // if no user image yet, just show text
    if (!userImage || !userImage.src) {
      log('Selected recipe: ' + (recipes[idx].title || 'Recipe ' + (idx+1)));
      return;
    }
    // run face mesh then drawComposites will be called
    runFaceMeshOnImage();
  }

  // initialize first preview when overlays are ready
  (async function init() {
    await Promise.all(overlayPromises);
    renderRecipes();
    updateSelectedUI();
    log('Overlays loaded: ' + Object.keys(overlayImgs).length);
    // if URL has recipe params, we already parsed them; preview first
    if (recipes && recipes.length>0) { previewRecipe(0); }
  })();

  </script>
</body>
</html>
